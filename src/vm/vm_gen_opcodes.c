#include <stdio.h>
#include <stdint.h>
#include <ctype.h>
#include "vm_misc.h"
#include "vm_opcodes.in"

static char *sanitize_mnem(const char *text)
{
	static char buffer[256];
	int i;
	for (i = 0; text[i] != '\0'; ++i) {
		buffer[i] = text[i] == '.' ? '_' : text[i];
	}
	buffer[i] = '\0';
	return buffer;
}

static uint8_t make_opcode_value(int index, int argcount)
{
	return index | (argcount << 6);
}

int main()
{
	FILE *fd;
	int index;
	
	fprintf(stdout, "Opcode count: %d\n", ARRAY_SIZE(opcodes));
	if (ARRAY_SIZE(opcodes) >= 64) {
		fprintf(stdout, "Too many opcodes: max %d\n", 64);
		return 1;
	}
	
	fprintf(stdout, "Generating vm_opcodes.h.\n");
	fd = fopen("vm_opcodes.h", "w");
	fprintf(fd, "#ifndef __mette_vm_opcodes_h_included\n#define __mette_vm_opcodes_h_included\n\n");
	fprintf(fd, "/* NOTE: AUTOGENERATED FILE. All editions will be discarded. */\n\n");
	fprintf(fd, "typedef enum {\n");
	for (index = 0; index < ARRAY_SIZE(opcodes); ++index) {
		fprintf(fd, "\t/* %s */\n", opcodes[index].description);
		fprintf(fd, "\tVMOP_%s\t\t= 0x%02X, /* %d -> %d */\n",
			sanitize_mnem(opcodes[index].mnemonic), 
			make_opcode_value(index, opcodes[index].stack_in),
			opcodes[index].stack_in,
			opcodes[index].stack_out);
	}
	fprintf(fd, "} vm_opcode_t;\n\n");
	fprintf(fd, "#endif // __mette_vm_opcodes_h_included\n\n");
	fclose(fd);
	
	fprintf(stdout, "Generating vm_opcodes_switch.tab.\n");
	fd = fopen("vm_opcodes_switch.tab", "w");
	fprintf(fd, "/* NOTE: AUTOGENERATED FILE. All editions will be discarded. */\n\n");
	fprintf(fd, "static const unsigned short offtab[64] = {\n");
	for (index = 0; index < ARRAY_SIZE(opcodes); ++index) {
		if (opcodes[index].mnemonic) {
			fprintf(fd, "\t&&op_%s - &&op_invalid,\n", sanitize_mnem(opcodes[index].mnemonic));
		} else {
			fprintf(fd, "\t0,\n");
		}
	}
	fprintf(fd, "};\n\n");
	fclose(fd);
	
	fprintf(stdout, "Generating vma_lexer.ops.tab.\n");
	fd = fopen("vma_lexer.ops.tab", "w");
	for (index = 0; index < ARRAY_SIZE(opcodes); ++index) {
		const char *mnem = opcodes[index].mnemonic;
		if (mnem) {
			int i;
			for (i = 0; mnem[i]; ++i) {
				if (isalpha(mnem[i])) {
					fprintf(fd, "[%c%c]", tolower(mnem[i]), toupper(mnem[i]));
				} else {
					fprintf(fd, "[%c]", mnem[i]);
				}
			}
			fprintf(fd, " return OP_%s;\n", sanitize_mnem(opcodes[index].mnemonic));
		}
	}
	fclose(fd);
	
	fprintf(stdout, "Generating vma_insn.ops.tab.\n");
	fd = fopen("vma_insn.ops.tab", "w");
	fprintf(fd, "/* NOTE: AUTOGENERATED FILE. All editions will be discarded. */\n\n");
	fprintf(fd, "static const uint8_t vma_insn_to_opcode[64] = {");
	for (index = 0; index < ARRAY_SIZE(opcodes); ++index) {
		if ((index & 0x07) == 0) {
			fputs("\n\t", fd);
		}
		if (opcodes[index].mnemonic) {
			fprintf(fd, "0x%02X, ", make_opcode_value(index, opcodes[index].stack_in));
		} else {
			fprintf(fd, "0x00, ");
		}
	}
	fprintf(fd, "\n};\n\n");
	fclose(fd);
	
	return 0;
}


